# Complete Schema-Driven Workflow

**Status**: Design Summary (v0.6.0+)
**Created**: 2025-10-06
**Purpose**: Demonstrates how all Phase 6 designs work together

## Overview

This document shows the **complete end-to-end workflow** combining all Phase 6 design documents into a single cohesive system.

## The Complete Vision

### Single Source of Truth: schema.surql

```sql
-- ============================================================================
-- DATABASE SCHEMA (Tables + Validation)
-- ============================================================================

DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON user TYPE string
  ASSERT string::len($value) >= 2;
DEFINE FIELD email ON user TYPE string
  ASSERT string::is::email($value);
DEFINE FIELD role ON user TYPE string
  ASSERT $value IN ['user', 'admin']
  VALUE $value OR 'user'
  PERMISSIONS FOR update WHERE $auth.role = 'admin';

DEFINE TABLE order SCHEMAFULL;
DEFINE FIELD user_id ON order TYPE record<user>;
DEFINE FIELD status ON order TYPE string
  ASSERT $value IN ['pending', 'active', 'cancelled', 'completed'];
DEFINE FIELD total ON order TYPE decimal
  ASSERT $value >= 0;

-- ============================================================================
-- CUSTOM FUNCTIONS (Business Logic)
-- ============================================================================

DEFINE FUNCTION fn::getProfile($userId: string) {
  SELECT id, name, email, role FROM $userId LIMIT 1;
};

DEFINE FUNCTION fn::getActiveOrders($userId: string) {
  RETURN SELECT * FROM order
    WHERE user_id = $userId
      AND status = 'active'
    ORDER BY created_at DESC;
};

DEFINE FUNCTION fn::cancelOrder($orderId: string) {
  UPDATE $orderId SET
    status = 'cancelled',
    cancelled_at = time::now();

  RETURN { success: true };
};

-- ============================================================================
-- JSÃ¶N DOCUMENT STORAGE (Variant-Aware)
-- ============================================================================

DEFINE TABLE jsÃ¶n_documents SCHEMAFULL;
DEFINE FIELD data ON jsÃ¶n_documents TYPE object;
DEFINE FIELD created_at ON jsÃ¶n_documents TYPE datetime VALUE time::now();
DEFINE FIELD updated_at ON jsÃ¶n_documents TYPE datetime VALUE time::now();
```

### Auto-Generated Outputs

From this **single schema file**, the system auto-generates:

#### 1. Zod Schemas (Validation)

```typescript
// schema.generated.zod.ts (AUTO-GENERATED)

export const UserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  role: z.enum(['user', 'admin']).default('user')
});

export const OrderSchema = z.object({
  user_id: z.string(), // record<user>
  status: z.enum(['pending', 'active', 'cancelled', 'completed']),
  total: z.number().min(0)
});

// Function schemas
export const GetProfileSchema = {
  input: z.tuple([z.string()]),
  output: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email(),
    role: z.enum(['user', 'admin'])
  })
};

export const GetActiveOrdersSchema = {
  input: z.tuple([z.string()]),
  output: z.array(OrderSchema)
};

export const CancelOrderSchema = {
  input: z.tuple([z.string()]),
  output: z.object({ success: z.boolean() })
};
```

#### 2. TypeScript Types (Type Safety)

```typescript
// schema.generated.d.ts (AUTO-GENERATED)

export type User = z.infer<typeof UserSchema>;
export type Order = z.infer<typeof OrderSchema>;

export interface DatabaseFunctions {
  getProfile(userId: string): Promise<{
    id: string;
    name: string;
    email: string;
    role: 'user' | 'admin';
  }>;

  getActiveOrders(userId: string): Promise<Order[]>;

  cancelOrder(orderId: string): Promise<{ success: boolean }>;
}

export type DB = { db: DatabaseFunctions };
```

#### 3. Dotted-JSON Resolvers (Runtime Execution)

```typescript
// Auto-generated by withSurrealDB plugin

const plugin = await withSurrealDB({
  url: 'ws://localhost:8000/rpc',
  namespace: 'my_app',
  database: 'main',
  schema: './schema.surql',  // â† Parses this file
  autoDiscoverFunctions: true,
  autoGenerateZod: true
});

// plugin.resolvers now contains:
// {
//   db: {
//     getProfile: async (userId: string) => { /* calls fn::getProfile */ },
//     getActiveOrders: async (userId: string) => { /* calls fn::getActiveOrders */ },
//     cancelOrder: async (orderId: string) => { /* calls fn::cancelOrder */ }
//   }
// }
```

#### 4. Permission Detection (Field-Level)

```typescript
// Auto-generated permission manager

const permissions = await plugin.permissions.getFieldPermissions('user');

// permissions:
// {
//   name: { canRead: true, canWrite: true },
//   email: { canRead: true, canWrite: true },
//   role: {
//     canRead: true,
//     canWrite: $auth.role === 'admin'  // â† From PERMISSIONS clause
//   }
// }
```

#### 5. Storage Provider (Variant-Aware)

```typescript
// Auto-configured SurrealDBLoader with array Record IDs

const loader = plugin.loader;

// Save JSÃ¶N documents with variants (uses array Record IDs)
await loader.save('greetings', { hello: 'Hello' }, { lang: 'en' });
// Creates: jsÃ¶n_documents:['greetings', 'en']

await loader.save('greetings', { hello: 'Hola' }, { lang: 'es' });
// Creates: jsÃ¶n_documents:['greetings', 'es']

// Range query (10-100x faster than WHERE clause)
const allGreetings = await loader.listVariants('greetings');
// Query: jsÃ¶n_documents:['greetings']..jsÃ¶n_documents:['greetings', '\uffff']
```

## Complete Usage Example

### Step 1: Define Schema (schema.surql)

```sql
-- Already shown above - this is the ONLY file you edit!
```

### Step 2: Generate Code (One Command)

```bash
# CLI tool generates everything from schema
bunx surql-codegen \
  --schema ./schema.surql \
  --output ./src/db.generated.ts \
  --watch

# Output:
# âœ… Generated 3 function resolvers
# âœ… Generated 5 Zod schemas
# âœ… Generated 8 TypeScript types
# âœ… Generated field permissions for 2 tables
# ðŸ“¦ Output: src/db.generated.ts (2.1 kB)
```

### Step 3: Use in Application (Zero Boilerplate)

```typescript
import { dotted } from '@orb-zone/dotted-json';
import { withSurrealDB } from '@orb-zone/dotted-json/plugins/surrealdb';

// Initialize plugin (auto-generates everything)
const plugin = await withSurrealDB({
  url: 'ws://localhost:8000/rpc',
  namespace: 'my_app',
  database: 'main',
  schema: './schema.surql',
  autoDiscoverFunctions: true,
  autoGenerateZod: true
});

// Use with dotted expressions
const userData = dotted({
  userId: 'user:alice',

  // Auto-complete suggests: getProfile, getActiveOrders, cancelOrder
  '.profile': 'db.getProfile(${userId})',

  // Nested function calls
  '.orders': 'db.getActiveOrders(${userId})',

  // Conditional logic
  '.hasOrders': '${.orders.length} > 0',

  // Use results from previous expressions
  '.firstOrderId': '${.orders[0].id}',

  // Mutations
  '.cancelFirst': '${.hasOrders} ? db.cancelOrder(${.firstOrderId}) : null'
}, {
  resolvers: plugin.resolvers,
  validation: plugin.validation
});

// All expressions are type-safe and validated!
const profile = await userData.get('.profile');
// Type: { id: string; name: string; email: string; role: 'user' | 'admin' }

const orders = await userData.get('.orders');
// Type: Order[]

const cancelResult = await userData.get('.cancelFirst');
// Type: { success: boolean } | null
```

### Step 4: Load/Save JSÃ¶N Documents (Variant-Aware)

```typescript
// i18n translations with variant resolution
const loader = plugin.loader;

// Save translations with language variants
await loader.save('ui.buttons', {
  submit: 'Submit',
  cancel: 'Cancel',
  delete: 'Delete'
}, { lang: 'en' });

await loader.save('ui.buttons', {
  submit: 'Enviar',
  cancel: 'Cancelar',
  delete: 'Eliminar'
}, { lang: 'es' });

// Load with variant context
const enButtons = await loader.load('ui.buttons', { lang: 'en' });
// Returns: { submit: 'Submit', cancel: 'Cancel', delete: 'Delete' }

const esButtons = await loader.load('ui.buttons', { lang: 'es' });
// Returns: { submit: 'Enviar', cancel: 'Cancelar', delete: 'Eliminar' }

// List all variants (range query)
const allButtonTranslations = await loader.listVariants('ui.buttons');
// Returns: [{ lang: 'en', data: {...} }, { lang: 'es', data: {...} }]
```

### Step 5: Permission-Aware UI (Auto-Generated)

```typescript
// Check field-level permissions before rendering form
const permissions = await plugin.permissions.getFieldPermissions('user', 'user:alice');

// Vue component example
<template>
  <form>
    <!-- Always editable -->
    <input v-model="user.name" :readonly="!permissions.name.canWrite" />

    <!-- Always editable -->
    <input v-model="user.email" :readonly="!permissions.email.canWrite" />

    <!-- Only admins can edit -->
    <select v-if="permissions.role.canRead" v-model="user.role" :disabled="!permissions.role.canWrite">
      <option>user</option>
      <option>admin</option>
    </select>
  </form>
</template>

<script setup>
const permissions = await plugin.permissions.getFieldPermissions('user', userId);
// permissions.role.canWrite = ($auth.role === 'admin')
</script>
```

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     schema.surql                            â”‚
â”‚                 (SINGLE SOURCE OF TRUTH)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                             â”‚
          â–¼                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  surql-to-zod CLI   â”‚       â”‚  INFO FOR DATABASE  â”‚
â”‚  (Parse .surql)     â”‚       â”‚  (Runtime Introspect)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                             â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚               â”‚               â”‚
          â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Zod Schemas    â”‚ â”‚  TS Types   â”‚ â”‚  Resolvers       â”‚
â”‚  (Validation)   â”‚ â”‚  (Safety)   â”‚ â”‚  (Execution)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚               â”‚               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Dotted Expressions â”‚
                â”‚   ".foo": "db.fn()" â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚               â”‚               â”‚
          â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Type   â”‚   â”‚  Runtime â”‚   â”‚  SurrealDB   â”‚
    â”‚  Check  â”‚   â”‚  Valid.  â”‚   â”‚  Execution   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Benefits Summary

### For Developers

| Traditional Approach | Schema-Driven Approach |
|---------------------|------------------------|
| Define DB schema | âœ… Define DB schema |
| Manually write API routes | âŒ Auto-generated resolvers |
| Manually write Zod schemas | âŒ Auto-generated from schema |
| Manually write TypeScript types | âŒ Auto-inferred from Zod |
| Manually sync on changes | âŒ Auto-sync on schema change |
| Test API endpoints | âœ… Test database functions |
| **Result**: 4 sources of truth, frequent drift | **Result**: 1 source of truth, zero drift |

### Performance Comparison

| Operation | Traditional (REST) | Schema-Driven (SurrealDB fn::) | Speedup |
|-----------|-------------------|-------------------------------|---------|
| Fetch user profile | 1 HTTP request + SQL query | 1 WebSocket call | 2-3x |
| Fetch profile + orders | 2 HTTP requests + 2 SQL queries | 1 fn:: call | 5-10x |
| Complex join queries | N+1 queries | 1 fn:: call | 10-50x |
| Permission check | Server-side middleware | DB-level PERMISSIONS | Instant |
| Type validation | Manual Zod code | Auto-generated | 0 effort |

### Bundle Size Comparison

| Traditional Stack | Schema-Driven Stack | Savings |
|-------------------|---------------------|---------|
| REST client (5 kB) | âŒ Not needed | -5 kB |
| GraphQL client (30 kB) | âŒ Not needed | -30 kB |
| Manual Zod schemas (10 kB) | âœ… Auto-generated (same) | 0 kB |
| Manual TypeScript types (0 kB) | âœ… Auto-generated (0 kB) | 0 kB |
| Custom API layer (50 kB) | âŒ Not needed | -50 kB |
| SurrealDB client (15 kB) | âœ… Required | +15 kB |
| Dotted-JSON core (18 kB) | âœ… Required | +18 kB |
| **Total Frontend Bundle** | ~95 kB | ~33 kB | **-62 kB (65% smaller)** |

## Code Comparison

### Traditional Approach (Manual Everything)

```typescript
// 1. Database schema (schema.sql)
CREATE TABLE users (
  id UUID PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE,
  role VARCHAR(50) DEFAULT 'user'
);

// 2. Backend API (routes/users.ts)
app.get('/api/users/:id', async (req, res) => {
  const user = await db.query('SELECT * FROM users WHERE id = $1', [req.params.id]);
  res.json(user);
});

// 3. Zod schema (schemas/user.ts)
export const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(2),
  email: z.string().email(),
  role: z.enum(['user', 'admin'])
});

// 4. TypeScript types (types/user.ts)
export type User = z.infer<typeof UserSchema>;

// 5. Frontend API client (api/users.ts)
export async function getUser(id: string): Promise<User> {
  const res = await fetch(`/api/users/${id}`);
  const data = await res.json();
  return UserSchema.parse(data);
}

// 6. Usage in component
const user = await getUser('123');
```

**Total**: 6 files, ~100 lines of code

### Schema-Driven Approach (Auto-Generated)

```sql
-- schema.surql (ONLY FILE TO EDIT)
DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON user TYPE string ASSERT string::len($value) >= 2;
DEFINE FIELD email ON user TYPE string ASSERT string::is::email($value);
DEFINE FIELD role ON user TYPE string ASSERT $value IN ['user', 'admin'];

DEFINE FUNCTION fn::getUser($userId: string) {
  SELECT * FROM $userId LIMIT 1;
};
```

```typescript
// Usage (everything else auto-generated)
const plugin = await withSurrealDB({ schema: './schema.surql' });

const data = dotted({
  userId: 'user:123',
  '.user': 'db.getUser(${userId})'
}, {
  resolvers: plugin.resolvers
});

const user = await data.get('.user');
```

**Total**: 1 schema file + 8 lines of code

**Result**: **~90% less code**, zero drift, full type safety

## Migration Path

### From Traditional REST API

1. **Phase 1**: Add SurrealDB alongside existing REST API
2. **Phase 2**: Define schema.surql matching existing database
3. **Phase 3**: Create fn:: functions that wrap existing business logic
4. **Phase 4**: Generate types/schemas from schema.surql
5. **Phase 5**: Migrate frontend to use dotted expressions
6. **Phase 6**: Retire REST API, pure SurrealDB fn:: calls

### From GraphQL

1. **Phase 1**: Map GraphQL schema to SurrealDB schema
2. **Phase 2**: Convert GraphQL resolvers to fn:: functions
3. **Phase 3**: Generate Zod/TypeScript from schema.surql
4. **Phase 4**: Replace GraphQL client with dotted expressions
5. **Phase 5**: Retire GraphQL server, pure SurrealDB

## Testing Strategy

### Unit Tests (Mock SurrealDB)

```typescript
describe('Auto-Generated Resolvers', () => {
  it('should generate resolver for each fn:: definition', () => {
    const functions = [
      { name: 'fn::getProfile', params: [{ name: 'userId', type: 'string' }] }
    ];

    const resolvers = generateFunctionResolvers(mockDB, functions);

    expect(resolvers.db.getProfile).toBeInstanceOf(Function);
  });
});
```

### Integration Tests (Real SurrealDB)

```typescript
describe('Schema-Driven Workflow', () => {
  it('should execute auto-generated resolver against real DB', async () => {
    const plugin = await withSurrealDB({
      url: 'http://127.0.0.1:9000/rpc',
      schema: './test-schema.surql'
    });

    const data = dotted({
      userId: 'user:test',
      '.profile': 'db.getProfile(${userId})'
    }, {
      resolvers: plugin.resolvers
    });

    const profile = await data.get('.profile');
    expect(profile).toHaveProperty('name');
  });
});
```

## Implementation Roadmap

- âœ… **v0.6.0-design**: All design documents complete
- ðŸ”œ **v0.7.0**: SurrealDBLoader + function discovery
- ðŸ”œ **v0.8.0**: Zod auto-generation + field permissions
- ðŸ”œ **v0.9.0**: surql-to-ts CLI + type generation
- ðŸ”œ **v1.0.0**: Production-ready with full docs

## References

- [Storage Providers Design](storage-providers-design.md)
- [SurrealQL to Zod Inference](surql-to-zod-inference.md)
- [Function Resolver Inference](function-resolver-inference.md)
- [Field-Level Permissions](field-level-permissions-design.md)
- [Record ID Variants](record-id-variants-design.md)
- [SurrealDB Vue Vision](surrealdb-vue-vision.md)
- [Integration Patterns](integration-patterns.md)

## Changelog

- **2025-10-06**: Initial workflow summary combining all Phase 6 designs
